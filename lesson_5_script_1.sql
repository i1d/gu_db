USE shop;

-- 1. Пусть в таблице users поля created_at и updated_at оказались незаполненными. Заполните их текущими датой и временем.
UPDATE users SET created_at = NULL, updated_at = NULL;
SELECT * FROM users;
UPDATE users SET created_at = NOW(), updated_at = NOW();
SELECT * FROM users;

-- 2. Таблица users была неудачно спроектирована. Записи created_at и updated_at были заданы типом VARCHAR 
-- и в них долгое время помещались значения в формате 20.10.2017 8:10. 
-- Необходимо преобразовать поля к типу DATETIME, сохранив введённые ранее значения.
DESC users;
ALTER TABLE users ADD created_var VARCHAR(50);
UPDATE users SET created_var = created_at;
SELECT * FROM users;
ALTER TABLE users ADD created_dt DATETIME;
UPDATE users SET created_dt = created_var;
SELECT * FROM users;
-- подозреваю, что в некоторых ОС может быть иное поведение, хотя у меня на ubuntu сработало прямое присваивание 
-- между столбцами разных типов без дополнительной конвертации и каких либо потерь данных.
-- то есть, один из способов - создать новую колонку, перенести туда данные, а потом удалить неправильную колонку.

-- второй способ - модифицировать колонку. здесь также могут быть нюансы в зависимости от типа, к которому мы преобразовываем данные.
ALTER TABLE users MODIFY created_var DATETIME;

-- 3. В таблице складских запасов storehouses_products в поле value могут встречаться самые разные цифры: 
-- 0, если товар закончился и выше нуля, если на складе имеются запасы. Необходимо отсортировать записи таким образом, 
-- чтобы они выводились в порядке увеличения значения value. Однако нулевые запасы должны выводиться в конце, после всех записей.
SELECT * FROM storehouses_products; -- таблица пустая - заполним данными:
INSERT INTO storehouses_products VALUES ('1','45','71','13','1985-09-27 08:51:55','1972-03-11 19:08:03'),
('2','51','38','00','1991-05-06 21:19:54','1990-04-05 01:31:12'),
('3','65','26','0','1985-06-28 21:25:16','1994-02-26 17:35:45'),
('4','19','8','39','2020-09-27 02:49:33','2018-08-21 01:50:05'),
('5','73','37','0','1972-10-05 08:12:08','1996-09-12 20:18:34'),
('6','2','4','26','1987-06-06 03:06:50','1972-11-30 17:30:52'),
('7','55','61','13','1974-11-07 20:23:49','2018-07-21 21:11:21'),
('8','85','87','47','1995-06-04 12:35:06','1984-07-11 05:26:07'),
('9','74','21','4','1978-01-30 06:43:56','2005-01-24 21:50:28'),
('10','90','63','0','1991-06-20 14:11:58','2012-09-07 19:29:58'),
('11','88','26','13','2020-11-02 05:17:26','1990-12-04 20:06:20'),
('12','46','59','43','2013-07-16 09:57:51','1986-02-20 18:08:01'),
('13','99','69','0','2018-12-07 05:18:30','1983-04-11 23:02:17'),
('14','48','86','17','2007-11-02 21:25:31','1998-08-30 19:42:12'),
('15','57','17','21','1991-01-27 18:43:56','2000-07-13 10:22:33'),
('16','27','42','0','2007-09-25 15:40:26','1985-08-22 22:44:04'),
('17','77','34','7','1975-04-19 02:06:02','2017-06-20 07:04:06'),
('18','35','59','40','1974-06-19 23:06:10','1971-03-08 11:16:16'),
('19','14','40','7','1989-09-25 03:44:39','2010-02-02 14:44:43'),
('20','72','92','38','2012-09-10 01:14:58','2019-08-18 23:32:19'),
('21','73','41','22','2018-10-28 01:41:57','2018-11-04 01:03:46'),
('22','69','13','0','1986-08-28 12:33:47','1978-02-24 05:52:12'),
('23','54','44','21','2016-10-07 14:11:22','1998-02-03 19:38:04'),
('24','33','8','8','2015-05-23 07:56:55','2007-10-13 10:13:20'),
('25','94','72','26','2015-04-12 13:55:49','1980-08-23 06:51:13'),
('26','43','48','48','2019-10-18 03:51:21','1986-07-15 23:20:33'),
('27','52','27','21','2009-09-05 01:01:35','1975-11-24 00:41:11'),
('28','20','63','0','2011-12-11 06:10:49','2011-12-02 00:39:50'),
('29','98','52','10','1982-03-16 05:44:39','1994-09-20 13:19:47'),
('30','43','21','0','1990-01-19 13:11:12','1977-06-10 23:24:40'); 


-- почему-то такая конструкция работает криво и не сортирует.
SELECT * FROM storehouses_products WHERE value > 0 ORDER BY value ASC
UNION 
SELECT * FROM storehouses_products WHERE value = 0;

-- поэтому пришлось применить костыль: (признаю, подсмотрел на stackoverflow - народ жалуется, что UNION криво работает с ORDER BY)
(SELECT *, 1 as sp FROM storehouses_products WHERE value > 0)
UNION
(SELECT *, 2 as sp FROM storehouses_products WHERE value = 0)
 ORDER BY sp, value ASC;


-- 4. Из таблицы users необходимо извлечь пользователей, родившихся в августе и мае. Месяцы заданы в виде списка английских названий (may, august)
SELECT * FROM users;
SELECT STR_TO_DATE('AUG','%b');
SELECT STR_TO_DATE('31/04', '%d/%m');
SELECT STR_TO_DATE('04/31/2004', '%m/%d/%Y');
SELECT STR_TO_DATE('May 1','%M %d'); -- весьма странно, что большинство примеров из официального мануала - не работают, поэтому пришлось опять городить костыль :(

SELECT * FROM users WHERE MONTH(birthday_at) IN 
	(SELECT MONTH(STR_TO_DATE(CONCAT(mon, ' 01, 2000'),'%M %d,%Y')) FROM 
		(SELECT 'January' AS mon UNION 
		SELECT 'February' UNION
		SELECT 'March' UNION
		SELECT 'April' UNION
		SELECT 'May' UNION
		SELECT 'June' UNION
		SELECT 'July' UNION
		SELECT 'August' UNION
		SELECT 'September' UNION
		SELECT 'October' UNION
		SELECT 'November' UNION
		SELECT 'December') AS lst 
		WHERE mon IN ('May', 'August')
	);



-- 5. Из таблицы catalogs извлекаются записи при помощи запроса. SELECT * FROM catalogs WHERE id IN (5, 1, 2); Отсортируйте записи в порядке, заданном в списке IN.
SELECT * FROM catalogs WHERE id IN (5, 1, 2) ORDER BY FIELD(id, 5, 1, 2);


